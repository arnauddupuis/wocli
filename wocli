#!/usr/bin/perl

use strict;
use warnings;
use LWP::UserAgent;
use Data::Dumper;
use Getopt::Long;
use File::Path qw(make_path remove_tree);
use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error) ;
use XML::Simple qw(:strict);
use Term::ANSIColor qw(:constants);
use List::Util 1.33 'any';

# Setting autoflush to immediate flush.
$|++;

# Got the DB URL!!!
# It's at: http://clientupdate.curse.com/feed/Complete.xml.bz2
# Global variables
my %config = (
	db => "$ENV{HOME}/.wocli/cache/wocli_db.csv",
	installed_db => "$ENV{HOME}/.wocli/wocli_installed_db.csv",
	wow_dir => "",
	config_dir => "$ENV{HOME}/.wocli",
	config_file => "config",
	uri_category => '/addons/wow/category',
	uri_complete_db => 'http://clientupdate.curse.com/feed/Complete.xml.bz2',
	db_ttl => 7200,
);
my $DEBUG=0;
my $VERSION="0.7.0";
my $WOCLI_NONE = 'wocli-none';
my $DB_VERSION=3;
my $last_cache_build=-1;
my %cache_meta=();
my %addon_index = ();
my $total_page=1;
my $db = "wocli_db.csv";
my $addon_list_content="";
my %addon_table = ();
my %installed_addon_table = ();
my %base_urls = (
	base => 'http://www.curse.com',
	home => 'http://www.curse.com/addons/wow?page=1',
	category => 'http://www.curse.com/addons/wow/category',
);
my $ua;

# Options
my $opt_build_cache=0;
my $opt_wow_dir = "";
my $opt_extended_cache=0; # If set to 0 build quick cache, if set to 1 build full description cache.
my $opt_write_config=0;
# These 2 options are used for sub-process detailled cache building
my $opt_update_cache_page=0;
my $opt_unzip='/usr/bin/unzip';
my $opt_update_cache_standalone=0;
my $opt_update_cache_max_processes=0; # not used right now
my $opt_no_integrity_check=0; # This option prevent integrity checks (like trying to install an addon that isn't existing).
my $opt_db_ttl=-1;
my $opt_show_config=0;

# Methods

# Print debug messages when debug is enabled
sub debug_print {
	return unless $DEBUG;
	print "[debug] ",@_;
}

sub warning_print {
	print BOLD,RED,"WARNING",RESET,": ",@_;
}

sub info_print {
	print BOLD,BLUE,"INFO",RESET,": ",@_;
}

sub saveConfig {
	debug_print "Saving config file.\n";
	writeFile("$config{config_dir}/$config{config_file}","# This file was auto-generated by wocli.\nwow_dir=$opt_wow_dir\ndb=$config{db}\nuri_category=$config{uri_category}\ndb_ttl=$opt_db_ttl\n");
}

sub loadConfig {
	open(my $fh,"<","$config{config_dir}/$config{config_file}") or die "Can't open $config{config_dir}/$config{config_file} for reading\n";
	while(my $line = <$fh>){
		chomp($line);
		next if($line =~ /^\s*#/);
		if($line =~ /^\s*([^=]+)\s*=\s*(.+)\s*$/){
			debug_print "config defines '$1' with value '$2'\n";
			$config{$1}=$2;
		}
		else{
			print "[warning] '$line' is neither a comment nor a valid config line !\n";
		}
	}
	close($fh);
}

sub unzip {
	my ($file, $dest) = @_;
	$file =~ s/\\//g;
	$dest =~ s/\\//g;
	debug_print "2>&1 $opt_unzip '$file' -d '$dest' >> $config{config_dir}/unzip.log\n";
	my $status = system("2>&1 $opt_unzip -o '$file' -d '$dest' >> '$config{config_dir}/unzip.log'");
	if($status == 0){
		return (1, "$file unzipped successfully.");
	}
	elsif ($? == -1) {
		return (0,"failed to execute: $!");
	}
	elsif ($? & 127) {
		return (0,"child died with signal %d, %s coredump"), ($? & 127),  ($? & 128) ? 'with' : 'without';
	}
	else {
		return (0,"child exited with value %d"), $? >> 8;
	}

}

sub installAddon {
	my $addon_shortname = shift(@_);
	if($opt_no_integrity_check || ($addon_table{$addon_shortname})){
		my $response;
		if($opt_no_integrity_check || ($addon_table{$addon_shortname})){
			if($addon_table{$addon_shortname}->{DownloadUrl}){
				my $url = $addon_table{$addon_shortname}->{DownloadUrl};
				if($url=~ /^.*\/([^\/]+)$/){
					my $file = $1;
					debug_print "\tgot addon download URL: $url (dl to $config{config_dir}/cache/$file)\n";
					# TODO: Handle errors like said here: http://search.cpan.org/~riche/File-Path-2.11/lib/File/Path.pm#ERROR_HANDLING
					make_path("$config{config_dir}/cache") unless(-e "$config{config_dir}/cache");
					$response = $ua->get($url,':content_file'=>"$config{config_dir}/cache/$file");
					unless($response->is_success){
						return (0,"Installation failed due to download issue: ".$response->status_line."\n");
					}
					my ($status,$msg) = unzip("$config{config_dir}/cache/$file","$opt_wow_dir/Interface/AddOns/");
					if($status){
						$installed_addon_table{$addon_shortname} = $addon_table{$addon_shortname};
						debug_print "installAddon returning status: ok\n";
						return (1, "install complete.");
					}
					else{
						debug_print "installAddon returning status: NOT ok ($msg)\n";
						return (0, "installation failed due to unzip issue: $msg.");
					}
				}
				else{
					return(0,"Can't extract file name from URL: $url");
				}
			}
			else{
				return(0, "Couldn't extract download URL.");
			}
		}
	}
	else{
		return(0,"$addon_shortname is not a valid (existing) addon short name.");
	}
}

sub writeFile{
	my $file_name = shift(@_);
	open(my $fh,">:encoding(UTF-8)",$file_name) or die "Can't open $file_name for writing\n";
	print $fh join('',@_);
	close($fh);
}

sub writeCache{
	my $db_file = shift(@_);
	$db_file = $config{db} unless(defined($db_file));
	debug_print "writeCache: write in $db_file\n";
	
	open(my $fh,">:encoding(UTF-8)",$db_file) or die "Can't open $db_file for writing\n";
	print $fh "#!db_time=$last_cache_build|db_version=$DB_VERSION\n";
	debug_print "Cache header written: #!db_time=$last_cache_build|db_version=$DB_VERSION\n";
	# Dependcy types: Embedded, Required, Optional => we're saving deps in that order.
	foreach my $addon_shortname (sort keys(%addon_table)){
		# Set default value for CSV
		$addon_table{$addon_shortname}->{Dependencies}->{Embedded} = [$WOCLI_NONE] if(scalar( @{$addon_table{$addon_shortname}->{Dependencies}->{Embedded}} ) == 0 );
		$addon_table{$addon_shortname}->{Dependencies}->{Required} = [$WOCLI_NONE] if(scalar( @{$addon_table{$addon_shortname}->{Dependencies}->{Required}} ) == 0 );
		$addon_table{$addon_shortname}->{Dependencies}->{Optional} = [$WOCLI_NONE] if(scalar( @{$addon_table{$addon_shortname}->{Dependencies}->{Optional}} ) == 0 );
		$addon_table{$addon_shortname}->{Folders} = [$WOCLI_NONE] if( !defined($addon_table{$addon_shortname}->{Folders}) || scalar( @{$addon_table{$addon_shortname}->{Folders}} ) == 0 );
		
		print $fh "$addon_shortname;$addon_table{$addon_shortname}->{Id};$addon_table{$addon_shortname}->{Name};$addon_table{$addon_shortname}->{DownloadUrl};$addon_table{$addon_shortname}->{Version};$addon_table{$addon_shortname}->{Summary};".join('|',@{$addon_table{$addon_shortname}->{Dependencies}->{Embedded}}).";".join('|',@{$addon_table{$addon_shortname}->{Dependencies}->{Required}}).";".join('|',@{$addon_table{$addon_shortname}->{Dependencies}->{Optional}}).";".int($addon_table{$addon_shortname}->{Score}).";".join('|',@{$addon_table{$addon_shortname}->{Folders}})."\n";
	}
	close($fh);
	$cache_meta{db_time}=$last_cache_build;
}

sub loadCache {
	open(my $fh,"<",$config{db}) or die "Can't open $config{db} for reading\n";
	
	# Reading db meta data
	my $firstline = <$fh>;
	chomp($firstline);
	debug_print "first line of cache is: '$firstline'\n";
	if($firstline =~ /^#!db_time=(\d+)\|db_version=(\d)$/){
		$cache_meta{db_time}=$1;
		$cache_meta{db_version}=$2;
		if($cache_meta{db_version} != $DB_VERSION){
			warning_print "your cache version doesn't match the requirement. Cache will be rebuilt. If it doesn't fix the warning please submit a bug report at https://github.com/arnauddupuis/wocli/issues\n";
			updateCacheIfNeeded();
			return;
		}
		if($last_cache_build == -1){
			$last_cache_build = $cache_meta{db_time};
		}
	}
	else{
		$cache_meta{db_time}=0;
		$cache_meta{db_version}=0;
		warning_print "unable to find database time of build and/or version. Cache will be rebuilt, if it doesn't fix the warning please submit a bug report at https://github.com/arnauddupuis/wocli/issues\n";
		updateCacheIfNeeded();
		return;
	}
	
	%addon_index = ();
	%addon_table = ();
	while(my $line = <$fh>){
		chomp($line);
		my @split = split(/;/,$line);
		my $shortname = $split[0];
		if(scalar(@split) == 11 ){
			$addon_table{$shortname} = {Id => $split[1], Name => $split[2], DownloadUrl => $split[3], Version => $split[4], Summary => "$split[5]", Dependencies => {Embedded => [split(/\|/,$split[6])], Required => [split(/\|/,$split[7])], Optional => [split(/\|/,$split[8])]}, Score => $split[9], Folders => [split(/\|/,$split[10])] };
# 			debug_print "Adding $shortname to the addon_index with id $split[1]\n";
			$addon_index{$split[1]} = $shortname;
		}
		else{
			debug_print "Not enought field for: $shortname (".scalar(@split)."/10)\n";
			$addon_table{$shortname} = {Id => -1, Name => "$shortname", DownloadUrl => "", Version => "0.0.0", Summary => "", Dependencies => {Embedded => [], Required => [], Optional => []}, Score => 0};
		}
	}
	close($fh);
# 	debug_print Data::Dumper::Dumper(%addon_table),"\n";
}

sub writeInstalledCache{
	my $db_file = shift(@_);
	$db_file = $config{installed_db} unless(defined($db_file));
	debug_print "writeCache: write in $db_file\n";
	open(my $fh,">:encoding(UTF-8)",$db_file) or die "Can't open $db_file for writing\n";
	foreach my $addon_shortname (sort keys(%installed_addon_table)){
		print $fh "$addon_shortname;$installed_addon_table{$addon_shortname}->{Id};$installed_addon_table{$addon_shortname}->{Name};$installed_addon_table{$addon_shortname}->{DownloadUrl};$installed_addon_table{$addon_shortname}->{Version};$installed_addon_table{$addon_shortname}->{Summary}\n";
	}
	close($fh);
}

sub loadInstalledCache {
	open(my $fh,"<",$config{installed_db}) or die "Can't open $config{installed_db} for reading\n";
	while(my $line = <$fh>){
		chomp($line);
		my @split = split(/;/,$line);
		my $shortname = $split[0];
		if(scalar(@split) == 6 ){
			$installed_addon_table{$shortname} = {Id => $split[1], Name => $split[2], DownloadUrl => $split[3], Version => $split[4], Summary => "$split[5]"};
		}
		else{
			debug_print "Not enought field for: $shortname (".scalar(@split)."/6)\n";
			$installed_addon_table{$shortname} = {Id => -1, Name => "$shortname", DownloadUrl => "", Version => "0.0.0", Summary => ""};
		}
	}
	close($fh);
}

sub loadToc{
	my $toc_file = shift(@_);
	debug_print "Loading TOC file: $toc_file\n";
	my %toc_table=(shortname=>"",deps=>[],optdeps=>[],version=>"0.0.0",ischild=>0);
# 	opendir(my $dh, $opt_wow_dir) or die "Can't open directory $opt_wow_dir for reading\n";
# 	my @tocs = grep { /^.*\.toc$/i } readdir($dh);
# 	closedir $dh;
	open my $fh, "<","$toc_file" or die "Can't open $toc_file for reading\n";
	## Dependencies: AtlasLoot_Loader
	## LoadOnDemand: 1
	## OptionalDeps: Ace3, LibBabble-Boss-3.0, LibBabble-Faction-3.0, LibBabble-Inventory-3.0, LibBabble-ItemSet-3.0, LibBabble-Zone-3.0, LibDBIcon-1.0, LibDataBroker-1.1
	## X-Curse-Packaged-Version: v6.05.03
	## X-Curse-Project-Name: AtlasLoot Enhanced
	## X-Curse-Project-ID: atlasloot-enhanced
	while(my $line = <$fh>){
		chomp($line);
# 		debug_print "(loadToc): '$line'\n";
# 		my $shortname = "";
# 		my $name = "";
# 		my $version = "0.0.0";https://stormboard.com/
# 		my $updateversion = "0.0.0";
		
		if($line=~/^\s*##\s*X-Curse-Project-ID:\s*([^\s]+)/i){
			$toc_table{shortname}=$1;
			debug_print "(loadToc): found X-Curse-Project-ID => '$toc_table{shortname}'\n";
		}
		elsif( $line=~/^\s*##\s*X-Curse-Packaged-Version:\s*([^\s]+)/i ){
			$toc_table{version}=$1;
		}
		elsif( $line=~/^\s*##\s*Dependencies:\s*([^\s]+)/i ){
			$toc_table{deps}=[split(/,\s*/,$1)];
		}
		elsif( $line=~/^\s*##\s*OptionalDeps:\s*([^\s]+)/i ){
			$toc_table{optdeps}=[split(/,\s*/,$1)];
		}
		elsif($line=~/^\s*##\s*X-Child-Of:\s*([^\s]+)/i){
			debug_print "(loadToc): $toc_file is a child of $1\n";
			$toc_table{ischild}=1;
		}
		
	}
	
	close $fh;
	return(%toc_table);
}

sub updateCache {
	make_path("$config{config_dir}/cache/tmp/") unless( -d "$config{config_dir}/cache/tmp/");
	debug_print "Downloading new cache\n";
	print "Downloading cache...";
	system("rm -rf $config{config_dir}/cache/tmp/Complete*");
	my $response = $ua->get($config{uri_complete_db},':content_file'=>"$config{config_dir}/cache/tmp/Complete.xml.bz2");
	
	if($response->is_success){
		print "ok\n";
		debug_print "Unziping database\n";
		print "Unzipping database...";
		my $status = bunzip2 "$config{config_dir}/cache/tmp/Complete.xml.bz2" => "$config{config_dir}/cache/tmp/Complete.xml" or die "bunzip2 failed: $Bunzip2Error\n";
		print "ok\n";
		print "Parsing XML...";
		my $complete = XMLin("$config{config_dir}/cache/tmp/Complete.xml", KeyAttr => {}, ForceArray => [ 'CAddOnCategory', 'CAddOnFileDependency', 'CAddOnModule', 'a:string', 'CAddOnAuthor', 'CAddOnFile', 'CAddOnModule' ]);
# 		debug_print Data::Dumper::Dumper($complete),"\n";
		print "ok\n";
		my $wac = 0;
		my $tac = 0;
		print "Processing database...";
		foreach my $caddon (@{$complete->{'CAddOn'}}){
			if($caddon->{'CategorySection'}->{'GameID'} == 1){
				$wac++;
				$caddon->{'Summary'} =~ s/;/,/g;
				my @url = split(/\//,$caddon->{'WebSiteURL'});
				$addon_table{$url[$#url]} = { Id => $caddon->{'Id'}, Name => $caddon->{'Name'}, DownloadUrl => $caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'DownloadURL'}, Version => $caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'FileName'}, Summary => "$caddon->{'Summary'}", Dependencies => {Embedded => [], Required => [], Optional => []}, Score => 0, Folders => [] };
				
				# Getting dependencies
				if(defined($caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'Dependencies'}) && ref($caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'Dependencies'}) eq 'HASH' && defined($caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'Dependencies'}->{'CAddOnFileDependency'})){
					foreach my $dep ( @{$caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'Dependencies'}->{'CAddOnFileDependency'}} ){
						if( exists($addon_index{$dep->{AddOnId}}) && defined($addon_index{$dep->{AddOnId}}) ){
							# If $dep->{'Type'} is not in Embded, Required or Optional it will be ignored at cache writing time.
							debug_print "adding '$addon_index{$dep->{AddOnId}}' as '$dep->{'Type'}' dependency to $caddon->{Name}\n";
							push @{$addon_table{$url[$#url]}->{Dependencies}->{$dep->{'Type'}}}, $addon_index{$dep->{AddOnId}};
						}
					}
				}
				
				# Getting folders
				if(defined($caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'Modules'}) && ref($caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'Modules'}) eq 'HASH' && defined($caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'Modules'}->{'CAddOnModule'})){
					foreach my $dir ( @{$caddon->{'LatestFiles'}->{'CAddOnFile'}->[0]->{'Modules'}->{'CAddOnModule'}} ){
						debug_print "adding Folder '$dir->{Foldername}' to addon $url[$#url]\n";
						push @{$addon_table{$url[$#url]}->{Folders}}, $dir->{Foldername};
					}
				}
				
				$addon_table{$url[$#url]}->{Score} += int($caddon->{DownloadCount}/2) if( defined($caddon->{DownloadCount}) );
				$addon_table{$url[$#url]}->{Score} += $caddon->{CommentCount} if( defined($caddon->{CommentCount}) );
				$addon_table{$url[$#url]}->{Score} += int($caddon->{InstallCount}*1.5) if( defined($caddon->{InstallCount}) );
				$addon_table{$url[$#url]}->{Score} += int($caddon->{Likes}*20) if( defined($caddon->{Likes}) );
				$addon_table{$url[$#url]}->{Score} /= 4;
			}
			$tac++;
		}
		print "ok\n";
# 		debug_print Data::Dumper::Dumper(%addon_table),"\n";
		debug_print "WoW addons found (WoW/Total): $wac/$tac\n";
		print "Cache updated with $wac addons.\n\n";
		$last_cache_build=time();
		print "Writing cache on disk...";
		writeCache();
		print "ok\n";
		
	}
	else{
		print "not ok.\n";
		die "Error while downloading Curse.com database: ".$response->status_line."\n";
	}
	
}

sub updateCacheIfNeeded {
	my $time = time();
	my $f_update_cache=0;
	if(($time - $cache_meta{db_time}) >= $opt_db_ttl){
		debug_print "Cache outdated, re-building it.\n";
		my $ttd = -1;
		my $ttd_unit = "";
		if($opt_db_ttl < 60){
			$ttd = $opt_db_ttl;
			$ttd_unit = "second(s)";
		}
		elsif($opt_db_ttl >= 60 && $opt_db_ttl < 3600){
			$ttd = int( $opt_db_ttl/60 );
			$ttd_unit = "minute(s)";
		}
		else{
			$ttd = $opt_db_ttl/3600;
			$ttd_unit = "hour(s)";
		}
		print BOLD,YELLOW,"Cache update required:",RESET," your cache exceed the database time to live limit of $ttd $ttd_unit, so it will be updated now.\n";
		$f_update_cache=1;
	}
	elsif($cache_meta{db_version} != $DB_VERSION){
		print BOLD,YELLOW,"Cache update required:",RESET," your cache version is mismatching the required version, so it will be updated now.\n";
		$f_update_cache=1;
	}
	else{
		debug_print "Cache is not out of date: $time - $cache_meta{db_time} = ",($time - $cache_meta{db_time})," < $opt_db_ttl and DB_VERSION match $cache_meta{db_version}à == $DB_VERSION\n";
	}
	
	if($f_update_cache == 1){
		updateCache();
		print "Loading new cache...";
		loadCache();
		print "ok\n";
	}
	
}

sub removeAddon {
	my $addon_shortname = shift(@_);
	my $error_messages = "";
	if( exists( $installed_addon_table{$addon_shortname} ) ){
		if( exists($addon_table{$addon_shortname}->{Folders}) && defined($addon_table{$addon_shortname}->{Folders}) ){
			my $error = 0;
			foreach my $tmp_folder ( @{$addon_table{$addon_shortname}->{Folders}} ){
				debug_print "$addon_shortname: have folder '$tmp_folder'...";
				if( -e "$opt_wow_dir/Interface/AddOns/$tmp_folder" && -d "$opt_wow_dir/Interface/AddOns/$tmp_folder" ) {
					debug_print "OK\n";
					debug_print "Removing '$opt_wow_dir/Interface/AddOns/$tmp_folder'\n";
					if( system("2>&1 rm -rf $opt_wow_dir/Interface/AddOns/$tmp_folder >> $config{config_dir}/error.log") == 0 ){
						debug_print "'$opt_wow_dir/Interface/AddOns/$tmp_folder' removed.\n";
					}
					else{
						$error_messages .= "Couldn't remove directory '$opt_wow_dir/Interface/AddOns/$tmp_folder'. ";
						$error++;
					}
				}
				else{
					debug_print "NOT OK!!\n";
				}
			}
			unless($error > 0){
				debug_print "removing $addon_shortname from installed addon DB.\n";
				delete($installed_addon_table{$addon_shortname});
				return (1,"");
			}
			else{
				if( $error == scalar(@{$addon_table{$addon_shortname}->{Folders}}) ){
					return (0,"None of the addon folders could be removed so the addon will NOT be marked as removed. Here is a list of errors: $error_messages");
				}
				else {
					delete($installed_addon_table{$addon_shortname});
					return (1,"Some errors occured during removing. Please look at warnings before this line and try to fix it by end (it mostly is directory that couldn't be removed). Since some of the content has been removed wocli will mark the addon as uninstalled.");
				}
			}
		}
		else{
			return (0,"Cannot find folder list for addon ",BOLD,YELLOW,$addon_shortname,RESET,". It is impossible to safely remove the addon automatically. Sorry, but you will have to do it by hand.");
		}
	}
	else{
		return (0,"addon ",BOLD,YELLOW,$addon_shortname,RESET," is not installed or not tracked by ",BOLD,"wocli",RESET);
	}
}

sub showVersion {
	print BOLD,GREEN,"wocli",RESET," version ",BOLD,YELLOW,$VERSION,RESET,"\n\nThanks for your support!\n\n";
	exit(0);
}

sub showConfig{
	my $label="| WOCLI CONFIGURATION |";
	print " " x 15,"-" x length($label),"\n"," " x 15,"$label\n"," " x 15,"-" x length($label),"\n";
	foreach my $key (sort keys %config){
		print BOLD,$key,RESET," "x(20- length($key)),": "," $config{$key}\n";
	}
	print "\n";
}



# Getting options from command line.
GetOptions(
  "build-cache"=>\$opt_build_cache,
  "extended"=>\$opt_extended_cache,
  "update-cache-page=i"=>\$opt_update_cache_page,
  "update-cache-standalone"=>\$opt_update_cache_standalone,
  "wow-dir=s" => \$opt_wow_dir,
  "save" => \$opt_write_config,
  "no-integrity-check" => \$opt_no_integrity_check,
  "debug" => \$DEBUG,
  "db-ttl=i" => \$opt_db_ttl,
  "version" => \&showVersion,
  "show-config" => \$opt_show_config
);

# Loading configuration 
if( -e "$config{'config_dir'}/$config{'config_file'}" ){
	debug_print "Loading config from $config{'config_dir'}/$config{'config_file'}\n";
	loadConfig();
	$opt_wow_dir = $config{wow_dir} if($opt_wow_dir eq "");
	$opt_db_ttl = $config{db_ttl} if($opt_db_ttl == -1);
}
else{
	debug_print "File $config{'config_dir'}/$config{'config_file'} does not exists, going on with default values.\n";
}


debug_print "/!\\ DEBUG is enabled, it can generate a lot of output/!\\\n";
debug_print "WoW directory: $opt_wow_dir\n";
debug_print "Remaining args: ".join(',',@ARGV)."\n";
debug_print "DB: $config{db}\n";
debug_print "DB TTL: $opt_db_ttl\n";

mkdir $config{'config_dir'} unless (-e $config{'config_dir'});
mkdir "$config{'config_dir'}/cache" unless (-e "$config{'config_dir'}/cache");

showConfig() if($opt_show_config);

saveConfig() if($opt_write_config);

loadInstalledCache() if( -e $config{installed_db} );

$ua = LWP::UserAgent->new(agent => 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.94 Safari/537.36');
$ua->timeout(10);
$ua->env_proxy;

if( -e $config{db} && !$opt_build_cache ){
	debug_print "Loading cache (no download)\n";
	loadCache();
}
else{
	debug_print "Downloading new cache\n";
	updateCache();
}

die "Wocli v$VERSION.\ncommand required: install, update, remove, search, clean, builddb, buildcache.\n" unless(defined($ARGV[0]));

my $cmd = shift(@ARGV);
debug_print "Self is: $^X $0\n";
debug_print "COMMAND: $cmd\n";
# debug_print "Data structure for gatherer:\n",Data::Dumper::Dumper($addon_table{'gatherer'}),"\n";

if($cmd eq 'install') {
	updateCacheIfNeeded();
	my %installation = (Optional => [], Required => [], Embedded => [], Addons => [], NotFound => []);
	foreach my $addonToInstall (@ARGV){
		if( exists( $addon_table{$addonToInstall} ) ){
			push @{$installation{Addons}}, $addonToInstall;
			foreach my $dep_type ('Optional','Required','Embedded'){
				foreach my $dep ( @{ $addon_table{$addonToInstall}->{Dependencies}->{$dep_type} } ){
					next if($dep eq $WOCLI_NONE);
					next if(exists($installed_addon_table{$dep}) && $installed_addon_table{$dep}->{Version} >= $addon_table{$dep}->{Version});
					push @{$installation{$dep_type}}, $dep; 
				}
			}
		}
		else {
			push @{$installation{NotFound}}, $addonToInstall;
		}
	}
	
	print "The following addons will be ".BOLD.GREEN."installed".RESET.":\n",BOLD,GREEN,join(RESET.", ".BOLD.GREEN,@{$installation{Addons}}),RESET,"\n\n";
	my @menu = ("What do you want to do?\n");
	if( scalar( @{$installation{Required}} ) > 0 ){
		print "The following ".BOLD.YELLOW."dependencies are required".RESET." and will be installed:\n",BOLD,YELLOW,join(RESET.", ".BOLD.YELLOW,@{$installation{Required}}),RESET,"\n\n";
		push @menu,"R) Install addons + required dependencies.\n";
	}
	else{
		push @menu,"A) Install addons without installing any optional dependencies.\n";
	}
	
	if( scalar( @{$installation{Optional}} ) > 0 ){
		print "The following ".BOLD.CYAN."dependencies are optional".RESET." and SHOULD be installed:\n",BOLD,CYAN,join(RESET.", ".BOLD.CYAN,@{$installation{Optional}}),RESET,"\n\n";
		push @menu,"O) Install addons + required dependencies (if any) + optional dependencies.\n";
	}
	
	if( scalar( @{$installation{Embedded}} ) > 0 ){
		print "The following ".BOLD.MAGENTA."dependencies are nice to have".RESET." and MAY be installed:\n",BOLD,MAGENTA,join(RESET.", ".BOLD.MAGENTA,@{$installation{Embedded}}),RESET,"\n\n";
		push @menu,"E) Install addons + required dependencies (if any) + optional dependencies (if any) + nice to have dependencies.\n";
	}
	
	push @menu, "N) Do nothing and exit.\n> ";
	print join("",@menu);
	my $answer = <STDIN>;
	chomp($answer);
	exit(1) if($answer =~ /^n/i);
	my @addonsToInstall = ();
	if( $answer =~ /^A/i){
		debug_print "Adding addons to the install stack.\n";
		foreach my $val (@{$installation{Addons}}){
			push @addonsToInstall, $val unless grep{$_ eq $val} @addonsToInstall ;
		}
	}
	elsif( $answer =~ /^R/i){
		debug_print "Adding Required dependencies to the install stack.\n";
		foreach my $val (@{$installation{Addons}},@{$installation{Required}}){
			push @addonsToInstall, $val unless grep{$_ eq $val} @addonsToInstall ;
		}
	}
	elsif( $answer =~ /^O/i){
		debug_print "Adding Optional dependencies to the install stack.\n";
		foreach my $val (@{$installation{Addons}},@{$installation{Required}},@{$installation{Optional}}){
			push @addonsToInstall, $val unless grep{$_ eq $val} @addonsToInstall ;
		}
	}
	elsif( $answer =~ /^E/i){
		debug_print "Adding Embedded dependencies to the install stack.\n";
		foreach my $val (@{$installation{Addons}},@{$installation{Required}},@{$installation{Optional}},@{$installation{Embedded}}){
			push @addonsToInstall, $val unless grep{$_ eq $val} @addonsToInstall ;
		}
	}
	
	
	foreach my $addonToInstall (sort @addonsToInstall){
		print "Install:\t$addonToInstall"." "x(50- length($addonToInstall)).":\t";
		my ($status,$msg) = installAddon($addonToInstall);
		if($status){
			print BOLD,GREEN,"installed",RESET," ($installed_addon_table{$addonToInstall}->{Name} $installed_addon_table{$addonToInstall}->{Version}).\n";
		}
		else{
			print BOLD,RED,"installation failed ($msg).\n",RESET;
		}
	}
	writeInstalledCache();
}
elsif($cmd eq 'add'){
	updateCacheIfNeeded();
	foreach my $addonToAdd (@ARGV){
		print "Adding:\t$addonToAdd"." "x(50- length($addonToAdd)).":\t";
		if($addon_table{$addonToAdd}){
			$installed_addon_table{$addonToAdd} = $addon_table{$addonToAdd};
			print BOLD,GREEN,"added",RESET," ($installed_addon_table{$addonToAdd}->{Name} $installed_addon_table{$addonToAdd}->{Version}).\n";
		}
		else{
			print BOLD,RED,"addition failed (addon is not in the database).\n",RESET;
		}
	}
	writeInstalledCache();
}
elsif($cmd eq 'update'){
	updateCacheIfNeeded();
	debug_print "ls -1 $opt_wow_dir/Interface/AddOns/*/*.toc\n";
	my $norm_dir = $opt_wow_dir;
	$norm_dir =~ s/\\//g;
	my @toc_files = split(/\n/,`ls -1 '$opt_wow_dir'/Interface/AddOns/*/*.toc`);
	my @update_list = ();
	my %updatable = %installed_addon_table;
	foreach my $tf (@toc_files){
		my %toc_data = loadToc($tf);
		if(defined($toc_data{'shortname'}) &&  exists($addon_table{$toc_data{'shortname'}})){
			debug_print "UPDATE: $toc_data{'shortname'} IS AN ADDON FOUND IN THE DATABASE.\n";
# 			push(@update_list, $toc_data{'shortname'});
			$updatable{$toc_data{'shortname'}} = 1;
		}
		else {
			debug_print "update: $toc_data{'shortname'} is not a root addon provided by curse.\n";
		}
	}
	foreach my $key (keys(%updatable)){
		if(defined($installed_addon_table{$key})){
			if($addon_table{$key}->{Version} gt $installed_addon_table{$key}->{Version}){
				push(@update_list,$key);
				debug_print "addon: $key added to update queue.\n";
			}
			else{
				debug_print "addon: $key is already up to date.\n";
			}
		}
		else{
			push(@update_list,$key);
			debug_print "addon: $key added to update queue.\n";
		}
	}
	if(scalar(@update_list) > 0){
		print "Following addons are going to be updated:\n",join(', ',@update_list),"\nIs that ok? (y/n):";
		my $answer = <STDIN>;
		chomp($answer);
		exit if($answer=~ /^n/i);
		foreach my $addonToUpdate (@update_list){
			print "Update:\t$addonToUpdate"." "x(50- length($addonToUpdate)).":\t";
			my ($status,$msg) = installAddon($addonToUpdate);
			if($status){
				print BOLD,GREEN,"updated",RESET," ($installed_addon_table{$addonToUpdate}->{Name} $installed_addon_table{$addonToUpdate}->{Version}).\n";
			}
			else{
				print BOLD,RED,"update failed ($msg).\n",RESET;
			}
		}
		writeInstalledCache();
	}
	else{
		print "Your addons are already up-to-date.\n";
	}
}
elsif($cmd eq 'clean'){
	remove_tree("$config{config_dir}/cache",{error => \my $err});
	if (@$err) {
	for my $diag (@$err) {
		my ($file, $message) = %$diag;
		if ($file eq '') {
			print BOLD,RED,"general error: $message\n",RESET;
		}
		else {
			print BOLD,RED,"problem unlinking $file: $message\n",RESET;
		}
	}
	}
	else {
		print BOLD, GREEN,"Cache cleaned\n",RESET;
	}
}
elsif($cmd eq 'buildcache'){
	debug_print "Building new cache\n";
	updateCache();
}
elsif($cmd eq 'search'){
	updateCacheIfNeeded();
	my $query = join(" ", @ARGV);
	debug_print "search query is '$query'\n";
	my $exact_match = 0;
	if(exists($addon_table{$query})){
		print "Found one exact match:\n", BOLD, GREEN, $query, RESET,": $addon_table{$query}->{Summary}\n";
		$exact_match=1;
	}
	
	my $results=0;
	foreach my $key (keys(%addon_table)){
		if($key =~ /^.*$query.*$/i || $addon_table{$key}->{Summary} =~ /^.*$query.*$/i){
			$results++;
			print BOLD,GREEN, $key,RESET,": $addon_table{$key}->{Summary}\n";
		}
	}
	if($results > 0){
		print "\nFound ", BOLD, YELLOW, $results, RESET," results.\n\n";
	}
	
	if( $exact_match == 0 && $results == 0 ){
		print "Sorry, we found no matching results for: ",BOLD, RED,$query,RESET,"\n\n";
	}
}
elsif($cmd eq 'showconfig'){
	showConfig();
}
elsif($cmd eq 'remove'){
	my @addons_list = ();
	my %unique_addon_list = ();
	foreach my $pattern (@ARGV){
		if($pattern =~/\*/){
			$pattern =~ s/\*/\.\*/g;
			my $regexp = qr/$pattern/;
			my $found = 0;
			foreach my $tmp_addon (keys(%installed_addon_table)){
				if($tmp_addon =~/$regexp/i){
					debug_print "Adding addon '$tmp_addon' to the remove list because it matches '$regexp'.\n";
# 					push @addons_list, $tmp_addon;
					$unique_addon_list{$tmp_addon}=1;
					$found++;
				}
			}
			if($found == 0){
				$pattern =~ s/\.\*/\*/g;
				warning_print "No installed addons are matching this pattern: \"",BOLD,YELLOW,"$pattern",RESET,"\".\n";
			}
		}
		else{
			if( exists( $installed_addon_table{$pattern} ) ){
				$unique_addon_list{$pattern}=1;
# 				push @addons_list, $pattern;
			}
			else {
				warning_print "addon ",BOLD,YELLOW,"$pattern",RESET," is not installed or not tracked by ",BOLD,"wocli",RESET,".\n";
			}
		}
	}
	@addons_list = sort keys %unique_addon_list;
	die "Nothing to remove.\n" unless(scalar(@addons_list) > 0);
	print "Following addons are going to be removed:\n", join(', ', @addons_list),"\nIs that ok? (y/n):";
	my $answer =<STDIN>;
	chomp($answer);
	exit if( $answer =~ /^n/i);
	foreach my $addonToRemove (@addons_list){
		print "Remove:\t$addonToRemove"." "x(50- length($addonToRemove)).":\t";
		my ($status,$msg) = removeAddon($addonToRemove);
		if($status){
			my $extra_msg = '';
			$extra_msg .= " ($msg)" if($msg ne "");
			print BOLD,GREEN,"removed",RESET,"$extra_msg.\n";
		}
		else{
			print BOLD,RED,"failed to remove ($msg).\n",RESET;
		}
	}
	writeInstalledCache();
}
elsif($cmd eq 'installed'){
	print "Here is the list of World of Warcraft addons, installed on your computer:\n";
	foreach my $addon (sort keys %installed_addon_table){
		print "- ",BOLD,GREEN,"$installed_addon_table{$addon}->{Name}",RESET," ($installed_addon_table{$addon}->{Version})\n";
	}
}
elsif($cmd eq 'info'){
	if( exists( $addon_table{$ARGV[0]} ) ){
		print "Here are the informations about:",BOLD,GREEN,$ARGV[0],RESET,":\n";
		print BOLD,"Name: ",RESET, $addon_table{$ARGV[0]}->{Name}, "\n";
		print BOLD,"Version: ",RESET, $addon_table{$ARGV[0]}->{Version}, "\n";
		print BOLD,"Curse Id: ",RESET, $addon_table{$ARGV[0]}->{Id}, "\n";
		print BOLD,"Required dependencies: ",RESET, join(', ',@{$addon_table{$ARGV[0]}->{Dependencies}->{Required}}), "\n" if($addon_table{$ARGV[0]}->{Dependencies}->{Required}->[0] ne $WOCLI_NONE);
		print BOLD,"Optional dependencies: ",RESET, join(', ',@{$addon_table{$ARGV[0]}->{Dependencies}->{Optional}}), "\n" if($addon_table{$ARGV[0]}->{Dependencies}->{Optional}->[0] ne $WOCLI_NONE);
		print BOLD,"Embedded dependencies: ",RESET, join(', ',@{$addon_table{$ARGV[0]}->{Dependencies}->{Embedded}}), "\n" if($addon_table{$ARGV[0]}->{Dependencies}->{Embedded}->[0] ne $WOCLI_NONE);
		print BOLD,"Download Url: ",RESET, $addon_table{$ARGV[0]}->{DownloadUrl}, "\n";
		print BOLD,"Folders: ",RESET, join(', ',@{$addon_table{$ARGV[0]}->{Folders}}), "\n";
		print BOLD,"Wocli score: ",RESET, $addon_table{$ARGV[0]}->{Score}, "\n";
		print BOLD,"Status: ",RESET, exists($installed_addon_table{$ARGV[0]}) ? BOLD.GREEN."installed".RESET : BOLD.RED."not installed".RESET , "\n" ;
		print BOLD,"Summary: ",RESET, $addon_table{$ARGV[0]}->{Summary}, "\n";
		
	}
	else{
		warning_print "There is no addons with '$ARGV[0]' as a shortname in the database.\nUse search to find addons and their shortnames.\n";
	}
}
elsif($cmd eq 'detect'){
# 	$opt_wow_dir =~ s/\\(\s+)/$1/g;
	$opt_wow_dir =~ s/\\//g;
	if( -e $opt_wow_dir.'/Interface/AddOns/' ){
		print "Scanning your World of Warcraft installation...";
		opendir(my $dh, "$opt_wow_dir/Interface/AddOns/") or die "Can't open directory $opt_wow_dir/Interface/AddOns/ for reading\n";
		my %unique_dir = ();
		while(readdir $dh) {
			next if(/^\./);
			debug_print "Found addon dir: $_\n";
			$unique_dir{$_} = [];
                }
		closedir $dh;
		foreach my $addon_shortname (keys(%addon_table)){
			foreach my $dir ( keys(%unique_dir) ){
				if(any { /$dir/ } @{$addon_table{$addon_shortname}->{Folders}} ){
					push @{$unique_dir{$dir}}, $addon_shortname;
					debug_print "Found a match for directory '$dir' => $addon_shortname\n";
				}
			}
		}
		debug_print Data::Dumper::Dumper( %unique_dir ),"\n";
		my %unique_addon_list = ();
		foreach my $dir ( keys(%unique_dir) ){
			foreach my $addon_shortname (@{$unique_dir{$dir}}){
				$unique_addon_list{$addon_shortname} = 1; 
			}
		}
		my @finale_addon_list = ();
		foreach my $addon_shortname ( keys %unique_addon_list ){
			my $found_dirs = 0;
			foreach my $dir ( @{$addon_table{$addon_shortname}->{Folders}} ) {
				$found_dirs++ if( -e "$opt_wow_dir/Interface/AddOns/$dir" );
			}
			if( scalar( @{$addon_table{$addon_shortname}->{Folders}} ) == $found_dirs ){
				debug_print "Found perfect match, adding $addon_shortname to the list.\n";
				push @finale_addon_list, $addon_shortname;
			}
		}
		print "done\n";
		debug_print "Here is the list of detected addons: ", join(', ', @finale_addon_list),"\n";
		
		info_print "All detected addons are perfect matches, this means that they perfectly match the description (folder list) from Curse.com. Adding them to your installed database is safe and you can re-run anytime.\n\n";
		
		print "Following addons are going to be added to your installed database:\n",join(', ', sort @finale_addon_list),"\nIs that ok? (y/n) ";
		my $answer =<STDIN>;
		chomp($answer);
		exit if( $answer =~ /^n/i);
		
		foreach my $addonToAdd (sort @finale_addon_list){
			print "Adding:\t$addonToAdd"." "x(50- length($addonToAdd)).":\t";
			if($addon_table{$addonToAdd}){
				$installed_addon_table{$addonToAdd} = $addon_table{$addonToAdd};
				print BOLD,GREEN,"added",RESET," ($installed_addon_table{$addonToAdd}->{Name} $installed_addon_table{$addonToAdd}->{Version}).\n";
			}
			else{
				print BOLD,RED,"addition failed (addon is not in the database).\n",RESET;
			}
		}
		writeInstalledCache();
	}
	else{
		warning_print "Unable to detect addons because no addon directory in your World of Warcraft install. Path looked out: $opt_wow_dir/Interface/AddOns/\n";
	}
}
elsif($cmd eq 'wb'){
	my $addon_1 = shift(@ARGV);
	my $addon_2 = shift(@ARGV);
	if(exists($addon_table{$addon_1}) && exists($addon_table{$addon_2}) ){
		debug_print "Score $addon_1: $addon_table{$addon_1}->{Score}\n";
		debug_print "Score $addon_2: $addon_table{$addon_2}->{Score}\n";
		my $result = ($addon_table{$addon_1}->{Score} >= $addon_table{$addon_2}->{Score}) && $addon_1 || $addon_2;
		print "The Curse.com community prefers ",BOLD,GREEN,$result,RESET,"\n";
	}
	else{
		warning_print "$addon_1 doesn't exists in the addon database.\n" unless(exists($addon_table{$addon_1}));
		warning_print "$addon_2 doesn't exists in the addon database.\n" unless(exists($addon_table{$addon_2}));
	}
}
elsif($cmd eq 'recomend'){
	# TODO: implement
}
else{
	die "Unknown command: $cmd\n";
}

exit(0);
